You are a senior full-stack engineer building a production-ready MVP in Replit.

Build me a complete web application called **“Stripe Dispute Assistant”**.

The goal of this MVP:

- Connect to **one Stripe account** (using a secret key in environment variables — NO OAuth or Connect yet).
- Pull in **dispute data** from Stripe.
- Let the user **view a list of disputes**, click into a **dispute detail page**, and **upload evidence files** (invoice, tracking, chats, etc.) tied to that dispute.
- Generate a **PDF evidence packet** that summarizes the dispute and the uploaded evidence, in a Stripe-friendly format, and make that packet downloadable.
- In the UI, show a **dark hero “Connect/Start” home screen**, plus a **white analytics-style dashboard** once disputes are loaded (similar to a Stripe-like design).

We will later extend this to multi-user + Stripe Connect + auto-submit, but this MVP is single-account only.

────────────────────────────────────
HIGH-LEVEL ARCHITECTURE
────────────────────────────────────

Use a **monorepo structure** inside one Replit project:

- Root
  - `package.json` (root) with scripts to run client & server together
  - `/server` – Node.js + TypeScript + Express backend API
  - `/client` – React + TypeScript + Vite + Tailwind CSS frontend

The app should run with a **single command** at root:
- `npm run dev` → starts:
  - backend on port `4000`
  - frontend on port `5173`
- The Vite dev server should **proxy `/api/*` requests to `http://localhost:4000`** so the browser only talks to the frontend origin.

Use **TypeScript everywhere** (server + client).

────────────────────────────────────
ENVIRONMENT & CONFIGURATION
────────────────────────────────────

Use environment variables. At the project root, create a `.env.example` file with:

- `STRIPE_SECRET_KEY=sk_test_xxx`   # placeholder, actual value set in Replit secrets
- `APP_BASE_URL=http://localhost:5173`   # default for local dev
- (optional later: `PORT` for the backend; default can be 4000)

The **only “connection”** for now is: the presence of a valid `STRIPE_SECRET_KEY`. We will still show a “Connect Stripe” button in the UI, but all Stripe access is done with this single key (no OAuth yet).

On Replit, the user will set environment variables using the Secrets UI.

────────────────────────────────────
BACKEND – SERVER (Node + TS + Express)
────────────────────────────────────

Technology:

- Node.js
- TypeScript
- Express
- Stripe Node SDK
- Multer (for file uploads)
- pdfkit (for PDF generation)
- sqlite + Prisma ORM for local persistence

Folder structure under `/server`:

- `/server`
  - `package.json`
  - `tsconfig.json`
  - `src`
    - `index.ts`          → app entrypoint
    - `config.ts`         → loads env vars, validates STRIPE_SECRET_KEY, etc.
    - `stripeClient.ts`   → initializes and exports a Stripe client
    - `routes`
      - `disputes.ts`     → all dispute-related routes
      - `evidence.ts`     → evidence upload + retrieval
      - `packets.ts`      → PDF packet generation + download
    - `types.ts`          → shared TS types for API responses
  - `prisma`
    - `schema.prisma`
  - `uploads/`            → uploaded evidence files (on disk)
  - `packets/`           → generated PDF packets (on disk)

● **Dependencies (server)**
Install at `/server`:

- `express`
- `cors`
- `stripe`
- `multer`
- `pdfkit`
- `dotenv`
- `@prisma/client`
- `sqlite3`
- `zod` (for simple input validation)

Dev dependencies:

- `typescript`
- `ts-node-dev`
- `@types/express`
- `@types/node`
- `@types/multer`

────────────────────────────────────
PRISMA / DATABASE DESIGN (SQLite)
────────────────────────────────────

Use **SQLite** via Prisma for a simple local DB. In `/server/prisma/schema.prisma`:

- Provider: `sqlite`
- Use a file called `dev.db` in the server folder.

Define models:

```prisma
datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator client {
  provider = "prisma-client-js"
}

model EvidenceFile {
  id          String   @id @default(cuid())
  stripeId    String   // Stripe dispute ID, e.g. du_xxx
  kind        String   // "invoice" | "tracking" | "chat" | "tos" | "screenshot" | "other"
  filename    String   // Original filename
  storedPath  String   // Path under uploads/
  sizeBytes   Int
  createdAt   DateTime @default(now())
}

model PdfPacket {
  id          String   @id @default(cuid())
  stripeId    String   // Stripe dispute ID
  filename    String   // e.g. packets/du_xxx_<timestamp>.pdf
  createdAt   DateTime @default(now())
}

In the server package.json, add a script:
•	"prisma:generate": "prisma generate"
•	"prisma:migrate": "prisma migrate dev --name init --skip-seed" (even though SQLite schema is simple)
On server startup, ensure Prisma client is initialized.
────────────────────────────────────
SERVER CONFIG – /server/src/config.ts
────────────────────────────────────
Implement a config module that:
•	Loads .env with dotenv.config() at server startup.
•	Exposes:
•	export const STRIPE_SECRET_KEY = process.env.STRIPE_SECRET_KEY!;
•	export const APP_BASE_URL = process.env.APP_BASE_URL || "http://localhost:5173";
•	If STRIPE_SECRET_KEY is missing, log a clear warning and allow the server to start, but the /api/disputes endpoints should return a friendly error message like "Stripe not configured".
────────────────────────────────────
STRIPE CLIENT – /server/src/stripeClient.ts
────────────────────────────────────
Create a Stripe client module:
import Stripe from "stripe";
import { STRIPE_SECRET_KEY } from "./config";

export const stripe = new Stripe(STRIPE_SECRET_KEY, {
  apiVersion: "2024-06-20", // or latest available in the Stripe SDK used
});
────────────────────────────────────
SERVER ENTRYPOINT – /server/src/index.ts
────────────────────────────────────
Implement Express app:
•	Use cors() with origin set to APP_BASE_URL and credentials: true.
•	Use express.json() for JSON bodies.
•	Use express.static to serve uploads and packets directories under /static/uploads and /static/packets for downloads.
•	Mount routers:
o	/api/disputes → routes/disputes.ts
o	/api/evidence → routes/evidence.ts
o	/api/packets → routes/packets.ts
•	Listen on port 4000 (or from process.env.PORT).
Add a simple health check at GET /api/health returning { ok: true }.
────────────────────────────────────
DISPUTE ROUTES – /server/src/routes/disputes.ts
────────────────────────────────────
Create an Express router that exports:
1. GET /api/disputes – list disputes
•	Use Stripe client: stripe.disputes.list({ limit: 50 }).
•	Map each dispute into a simplified object:
•	{
•	  id: d.id,
•	  charge: d.charge,
•	  reason: d.reason,
•	  amount: d.amount,        // keep in cents; frontend converts to currency
•	  currency: d.currency,
•	  status: d.status,        // needs_response | under_review | warning_closed | lost | won
•	  createdAt: d.created * 1000,
•	  dueBy: d.evidence_details?.due_by ? d.evidence_details.due_by * 1000 : null
•	}
•	Return { disputes: [...] }.
•	If STRIPE_SECRET_KEY is missing, return 503 with { error: "Stripe not configured" }.
2. GET /api/disputes/:id – get single dispute
•	Use stripe.disputes.retrieve(req.params.id).
•	Return { dispute: <full Stripe dispute object> }.
•	On error Stripe.errors.StripeInvalidRequestError with code resource_missing, return 404 JSON.
────────────────────────────────────
EVIDENCE ROUTES – /server/src/routes/evidence.ts
────────────────────────────────────
Purpose: manage evidence files tied to a Stripe dispute ID.
Use multer to accept file uploads and Prisma to store metadata.
•	Configure multer with destination uploads/ and a filename pattern like <timestamp>_<originalname>.
•	All evidence endpoints must require a stripeId parameter (the dispute id).
Routes:
1. GET /api/evidence/:stripeId
•	Query Prisma EvidenceFile where stripeId matches.
•	Return { evidence: [...] }.
2. POST /api/evidence/:stripeId/upload
•	Accept multipart/form-data with:
o	file (field name file)
o	kind string (one of: invoice, tracking, chat, tos, screenshot, other)
•	Validate kind with zod or simple check.
•	Store file on disk under uploads/, save record in Prisma with:
o	stripeId, kind, filename (original), storedPath (relative path from server root), sizeBytes.
•	Return { ok: true, evidence: <createdRecord> }.
────────────────────────────────────
PDF PACKET ROUTES – /server/src/routes/packets.ts
────────────────────────────────────
Purpose: generate and serve a PDF summary for a dispute.
Use pdfkit.
1. POST /api/packets/:stripeId – generate packet
•	Read stripeId from params.
•	Fetch dispute data from Stripe (stripe.disputes.retrieve(stripeId)).
•	Fetch evidence metadata from Prisma (EvidenceFile records for that stripeId).
•	Create a PDF file in packets/, named dispute_<stripeId>_<timestamp>.pdf.
•	In the PDF, include:
o	Title: “Stripe Dispute Evidence Packet – {stripeId}”
o	Section: “Dispute Summary”
	Amount, currency, reason, created date, status, due date
o	Section: “Customer & Charge”
	Use fields from the Stripe dispute to show charge id, maybe charge outcome, etc. (best effort).
o	Section: “Evidence Files”
	A table listing each file: kind, original filename, upload date.
o	Notes section: simple bullet list placeholders like “Attach these files in Stripe when submitting evidence.”
o	For MVP, we do not embed the actual binary file contents into the PDF; we just reference filenames and kinds.
•	Save record in Prisma PdfPacket with:
o	stripeId, filename (relative path under packets/).
•	Return { ok: true, packetId: <id>, downloadUrl: "/api/packets/download/<id>" }.
2. GET /api/packets/latest/:stripeId – fetch the latest packet metadata
•	Return the most recent PdfPacket for that stripeId or null.
3. GET /api/packets/download/:packetId – stream PDF
•	Look up PdfPacket by id.
•	Stream the file from disk with correct Content-Type: application/pdf and Content-Disposition: attachment; filename="...".
────────────────────────────────────
FRONTEND – CLIENT (React + Vite + TS + Tailwind)
────────────────────────────────────
Under /client:
•	Use Vite + React + TypeScript.
•	Configure Tailwind CSS.
Folder structure:
•	/client
o	package.json
o	vite.config.ts → proxy /api to http://localhost:4000
o	tailwind.config.cjs / postcss.config.cjs
o	src
	main.tsx
	App.tsx
	router.tsx (or inline routing)
	components
	Layout.tsx – top nav + shell
	cards/* – small UI components
	charts/* – simple “dummy” metrics (no need for real chart lib yet; can use SVG sparklines)
	pages
	Home.tsx
	Dashboard.tsx
	DisputesList.tsx
	DisputeDetail.tsx
	Settings.tsx
Use React Router with routes:
•	/ → Home
•	/app → Dashboard
•	/app/disputes → DisputesList
•	/app/disputes/:stripeId → DisputeDetail
•	/app/settings → Settings
────────────────────────────────────
FRONTEND STYLE & UX
────────────────────────────────────
General:
•	Use Tailwind + a modern, Stripe-like aesthetic.
•	Base tokens:
o	Dark hero: bg-[#0b1220], text-white, accents in indigo-500/600.
o	Light dashboard: bg-slate-50, cards bg-white shadow-sm rounded-2xl border border-gray-100.
•	Top nav across all /app/* routes:
o	Logo (simple purple square + “Stripe Dispute Assistant” text).
o	Nav links: Dashboard, Disputes, Settings.
Home page / – dark hero
•	A full-screen dark gradient background.
•	Headline: “Automatically detect and manage Stripe disputes”.
•	Subtext: “Connect your Stripe account to start tracking and responding to disputes.”
•	Primary button: “Go to dashboard” → navigates to /app.
•	Below hero: 3 glassy stat cards (static numbers for now):
o	“Open disputes: 5”
o	“Won disputes: 20”
o	“Lost disputes: 3”
Dashboard /app – light analytics
•	On mount, fetch GET /api/disputes.
•	Show:
o	KPIs row:
	Open disputes count
	Total amount at risk (sum of amount for needs_response and warning_needs_response – if available)
	Win rate (for now can be fake / derived from Stripe dispute statuses)
	Days until nearest due date
o	A simple line “win rate” chart (could be just a static SVG or placeholder).
o	A donut or pie representation of dispute reasons (fraudulent, unrecognized, etc.) – again, can be simple made-up data based on counts.
o	At bottom, a mini table of the 5 most recent disputes with a link “View all disputes” → /app/disputes.
Disputes list /app/disputes
•	On mount, call GET /api/disputes.
•	Show a big card with a table:
Columns:
o	Reason
o	Amount (formatted: Intl.NumberFormat with currency)
o	Status
o	Due
o	Stripe ID (monospace)
o	“Open →” link
•	Each row’s “Open →” links to /app/disputes/:stripeId.
•	Above the table, show filters (frontend-only for now):
o	Dropdown Status: All / Needs response / Under review / Closed / Won / Lost
o	Dropdown Reason: All / Fraudulent / Product not received / etc.
Dispute detail /app/disputes/:stripeId
On mount:
1.	Fetch GET /api/disputes/:stripeId.
2.	Fetch GET /api/evidence/:stripeId.
3.	Fetch GET /api/packets/latest/:stripeId (to show if a packet already exists).
Layout:
•	Header:
o	Title: Dispute du_xxx (monospace id)
o	“← Back to list” link.
•	Summary tiles (grid):
o	Reason
o	Amount (formatted)
o	Status
o	Due date
•	Section: “Evidence checklist”
o	Based on reason (fraudulent, product_not_received, etc.), show simple required / optional lists, e.g.:
	Required: invoice, tracking, customer communication
	Optional: refund policy, screenshot of login, etc.
o	For now, these can be hard-coded in the frontend in a small helper function: getEvidenceTemplate(reason).
•	Section: “Upload evidence”
o	A form:
	Select dropdown “Kind” (invoice, tracking, chat, tos, screenshot, other).
	File input (single file).
	Submit button.
o	On submit, POST multipart/form-data to /api/evidence/:stripeId/upload.
o	After success, refetch GET /api/evidence/:stripeId to update the list.
•	Section: “Existing evidence”
o	A table listing kind, filename, size, uploadedAt.
o	No need for delete yet.
•	Section: “Generate PDF packet”
o	If a packet exists (from GET /api/packets/latest/:stripeId), show:
	“Last generated packet at: <date>”
	Button: “Download latest packet” linking to /api/packets/download/:packetId.
o	Button: “Generate new PDF packet”
	On click, call POST /api/packets/:stripeId.
	Show a small loading state.
	After success, update the “latest packet” state and show a toast or inline success message.
Settings /app/settings
•	For this MVP, simply show:
o	Whether Stripe is configured (based on a GET /api/health or GET /api/disputes response).
o	Instructions: “Set STRIPE_SECRET_KEY in your environment (Replit secrets) to connect your Stripe account.”
o	Later we’ll add Stripe Connect OAuth, but not in this MVP.
────────────────────────────────────
FRONTEND – FETCH HELPERS & ERROR UI
────────────────────────────────────
•	Create a small fetch helper in /client/src/lib/api.ts that wraps fetch and throws on non-OK responses.
•	All pages should have simple loading and error states:
o	While fetching: “Loading…”
o	On error: a small red text box with the error message.
────────────────────────────────────
ROOT PACKAGE.JSON – RUN EVERYTHING
────────────────────────────────────
At the project root, create a package.json with scripts:
•	"install:all": "cd server && npm install && cd ../client && npm install"
•	"dev": "concurrently \"cd server && npm run dev\" \"cd client && npm run dev\""
Install concurrently at root.
Server package.json should have:
•	"dev": "ts-node-dev --respawn --transpile-only src/index.ts"
Client package.json should have:
•	"dev": "vite"
Configure Vite (client/vite.config.ts) to:
•	Set base port 5173
•	Proxy /api → http://localhost:4000
────────────────────────────────────
DONE CRITERIA (WHAT MUST WORK)
────────────────────────────────────
When you have finished building:
1.	Running npm run dev at the project root:
o	Starts Express server on 4000
o	Starts React app on 5173
2.	With a valid STRIPE_SECRET_KEY set (test key), visiting http://localhost:5173:
o	Shows the dark hero home
o	Clicking “Go to dashboard” shows a white dashboard
3.	Visiting /app/disputes:
o	Calls /api/disputes successfully
o	Renders a table of disputes from the Stripe account
4.	Clicking “Open →” on a dispute (e.g., du_xxx):
o	Goes to /app/disputes/du_xxx
o	Loads Stripe dispute data and shows summary
o	Shows evidence checklist
o	Allows uploading an evidence file and lists it after upload
o	Allows generating a PDF packet and downloading it
Please implement the full backend and frontend as described, including all routes, pages, and components.
If any implementation detail is ambiguous, choose the simplest, most robust option and keep the code clean and well-structured.
